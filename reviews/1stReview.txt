tar --exclude='.git/' --exclude='_SharedFiles/' --exclude='_Downloads/' --exclude='node_modules/' --exclude='dist/' --exclude='src/golang.org/' --exclude='src/github.com/gorilla/' --exclude='src/github.com/dedis/' --exclude='src/github.com/stretchr' --exclude='LiangweiCHEN/' --exclude='reviews/' -zcvf Fengyu.tar.gz src/

Review Homework 1 CS-438 Fall 2019

Reviewer Name: Fengyu Cai

----------
Review 0
----------
Score (min 1, max 5): 5

Advantages and Disadvantages (150-300 words):
1. Advantages:
a) Callback function:
The wide application of callback function can help a lot in the capsulation.
For example, we find that the function ``` NewTicker ``` can be used as
interfaces for other functions, which can help a lot the implementation of
process start and process termination.

b) Use tickers to memorize the rumor mongering status:
Also, as mentioned above, because there is tickers to memorize the launch and termination
of a process, we can take advantage of this to implement the process of rumor mongering.


c) Accelerate the process of information exchange:
I think this one is quite good, as I did not implement this way. In this way, the efficiency
of the information exchange is higher because of this. When receiving the status packet, this
code compares it with local wantlist. In this way, during one receipt of status packet, the gossiper
not only send the status packet to the sender if he has found that some of the packets have been missed,
but also, if there are some rumors that the sender missed, it can also start rumormongering to the sender
with the missing rumor.

2. Disadvantages:
a) The design of the lock:
All of the locks used as a member of the gossiper object, it may perhaps cause the lock of the whole object.
I think this could be the reason why there is a deadlock for the tick checking.

Design recommendations (100-200 words):

Based on the disadvantage mentioned above, I just purposed the following design mechanisim. It will be a better
design that the lock can be put inside the member of the object 'gossiper'. In this way, we can avoid the
case that one member of the gossiper will cause the block of the whole object. Perhaps, the following
design could be better.

For example:
LastSent and LastSentLock can be combined as
LastSentObject {
LastSent map[string]*hu.RumorMessage
LastSentLock sync.RWMutex
}

----------
Review 1
----------
Score (min 1, max 5): 5

Advantages and Disadvantages (150-300 words):
Advantages:
a) Very good OOP design
In this implementation, the most attractive point for me is that the members of gossiper have been modulized, such as
peerBook and database which is used to record the data. It will be easy to develop other features in the future.
What is more, it is also convenient for the test, e.g. in this implementation, we have database_test, daemons_test, and
gossiper_test. The script can test each part of the code, therefore, more convenient for debugging.

b) Clear logger:
Compared with other implementations, the most impressive feature of this implementation is clear logging.
There is a logger object. And each object can have a logging member, which is much easier for the record.

c) Very good efficiency for the code running
This implementation has a very careful concurrent design, taking full advantage of locks and channels. When doing the test,
it shows out a efficient performance for data synchronization.

Disadvantages:
a) Handle with Status packet
Not sure whether it is a disadvantage or not, and it is just a discussion. Normally speaking, when receiving a status packet,
the gossiper will check the difference between this list of status and the local status list. And after that,
the gossiper needs to decide whether to do rumormongering to the sender or send the status packet to ask for the new rumor.
As found in some implementations, these two steps can be done together.

b) How to decide which rumor should be mongered
What is more, the problem in which rumor should be mongered should be double considered.
If the rumor handler of the gossiper can not deal with the out-of-order case,
the gossiper should send the rumor which can be thought as the bottleneck for the rumor receiption.


Design recommendations (100-200 words):
a) For the first disadvantage about the manipulation of the status packet, it perhaps may be more effient to open two new goroutines
to send the rumor and send the status packet at the same time.

b) According to the second disadvantage, I think it is possible to build up a mechanisim to distinguish the urgency of the rumor.
For example, the local status list is like :
{
Origin: A;
NextID: 6;
}
{
Origin: B;
NextID: 2;
}

And the status packet list from the peer C is like following:
{
Origin: A;
NextID: 1;
}

{
Origin: B;
NextID: 1;
}

And in the case above, we could find that the demand of the rumor from origin A for C is more urgent than the rumor from the origin.
Meanwhile, for the rumor from Origin B, the ID 1 is more urgent than others for peer C. Therefore, we should send the rumor
(Origin: A, ID: 1) to peer C.


----------
Review 2
----------
Score (min 1, max 5): 3

Advantages and Disadvantages (150-300 words):
Disadvantages:
a) Just one lock
In the code, there is just one lock for the whole gossiper object. Normally, it is a good practice to keep the mutex close to the data
it is destined to protect. Therefore, it would be a better solution that we put the lock for every dataframe inside the gossiper object.

b) Weird infinite for loop:
I did not get the meaning why put an infinite for loop at the end of the main function. I believe there should be more applications
for the goroutines and channels. And also, the code need to build up some data frame to store the channel and wait for the status packet
as an acknowledgement from the receiver until timeout.

c) RumorMongering
There is no full implementation for the process of rumor-mongering. In this code, rumor-mongering is just to select one peer and send
it the corresponding rumor, however, there is no channel built to listen to the acknowledgment from the receiver.

d) Flip coin
I believe there is some wrong implementations about the flip coin mechanism. In the line 416, the operation after the flip coin is not starting
a new rumor-mongering, but send a new status packet to a random peer.

e) randomness of the peer
Some parts of peer randomness have some problems. For example, for the part of rumor-mongering, after acknowledging that we have received from
the user. In this case, we do not need to take the recent peer into account, which will cause the redundancy of the communication and the waste
of the network.

Design recommendations (100-200 words):
1) As mentioned in the part a) above, perhaps it is better to add different locks for different members of the gossiper object.

For example:
WantedList and WantedListLock can be combined as
WantedListObject {
WantedList map[string] *RumorMessage
WantedListLock sync.RWMutex
}

2) Based on the rumor-mongering, we can use launch a specific goroutine and store it as part of the object to wait for the acknowledgment from
the sender. A channel in GoLang would be helpful.

3) The flip coin should work as a rumor-mongering, instead of sending the status packet. And also, the randomness of peers should exclude the previous
peers.

4) I think there should be more OOP design. For example, for function 'Rumormonger' should be a member function of the class gossiper. However, in this
implementation, it put the gossiper as the input variable.